<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arcade Games</title>
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0; 
      padding: 0; 
      min-height: 100vh;
    }
    .container { 
      max-width: 600px; 
      margin: 40px auto; 
      background: #fff; 
      padding: 2.5em; 
      border-radius: 16px; 
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      text-align: center;
    }
    h2 { 
      text-align: center; 
      color: #333;
      margin-bottom: 1.5em;
      font-size: 2.2em;
    }
    .token-info { 
      text-align: center; 
      margin-bottom: 1.5em;
      font-size: 1.2em;
      font-weight: bold;
      color: #1976d2;
    }
    .user-email { 
      text-align: center; 
      margin-bottom: 1em;
      color: #666;
      font-style: italic;
    }
    .game-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 2em 0;
    }
    .game-card {
      background: linear-gradient(45deg, #f8f9fa, #e9ecef);
      border-radius: 12px;
      padding: 1.5em;
      border: 2px solid #e0e0e0;
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: pointer;
    }
    .game-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
      border-color: #1976d2;
    }
    .game-card.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .game-title {
      font-size: 1.3em;
      font-weight: bold;
      color: #333;
      margin-bottom: 0.5em;
    }
    .game-description {
      color: #666;
      margin-bottom: 1em;
      font-size: 0.9em;
    }
    .game-cost {
      color: #1976d2;
      font-weight: bold;
      font-size: 1.1em;
    }
    .back-link { 
      display: block; 
      text-align: center; 
      margin-top: 2em;
      color: #1976d2;
      text-decoration: none;
      font-weight: bold;
    }
    .back-link:hover {
      text-decoration: underline;
    }
    .game-area {
      display: none;
      margin-top: 2em;
    }
    .game-area.active {
      display: block;
    }
    .game-canvas {
      border: 2px solid #333;
      border-radius: 8px;
      background: #000;
      margin: 1em auto;
      max-width: 100%;
      height: auto;
    }
    
    .countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4em;
      font-weight: bold;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      z-index: 1000;
    }
    
    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
    }
    
    .mobile-btn {
      width: 60px;
      height: 60px;
      margin: 5px;
      border: none;
      border-radius: 50%;
      background: rgba(25, 118, 210, 0.8);
      color: white;
      font-size: 1.5em;
      cursor: pointer;
    }
    
    @media (max-width: 768px) {
      .mobile-controls {
        display: flex;
      }
      .game-canvas {
        width: 100%;
        max-width: 400px;
      }
    }
    .game-controls {
      margin: 1em 0;
    }
    button { 
      padding: 0.8em 1.5em; 
      background: linear-gradient(45deg, #1976d2, #42a5f5); 
      color: #fff; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer; 
      margin: 0.5em;
      font-size: 1em;
      font-weight: bold;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover { 
      background: linear-gradient(45deg, #0d47a1, #1976d2);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
  </style>
</head>
<body>
  <div class="container" id="main-container">
    <h2>üéÆ Arcade Games</h2>
    <div class="user-email" id="user-email"></div>
    <div class="token-info">Tokens: <span id="token-count"></span></div>
    
    <div class="game-grid">
      <div class="game-card" onclick="startGame('snake', 5)">
        <div class="game-title">üêç Snake Game</div>
        <div class="game-description">Classic snake game. Eat food to grow longer!</div>
        <div class="game-cost">Cost: 5 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('tetris', 10)">
        <div class="game-title">üß© Tetris</div>
        <div class="game-description">Stack blocks and clear lines!</div>
        <div class="game-cost">Cost: 10 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('puzzle', 3)">
        <div class="game-title">üß© Number Puzzle</div>
        <div class="game-description">Slide tiles to arrange numbers in order!</div>
        <div class="game-cost">Cost: 3 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('flappy', 4)">
        <div class="game-title">üê¶ Flappy Bird</div>
        <div class="game-description">Navigate through pipes with spacebar!</div>
        <div class="game-cost">Cost: 4 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('breakout', 6)">
        <div class="game-title">üèì Breakout</div>
        <div class="game-description">Break all the blocks with your paddle!</div>
        <div class="game-cost">Cost: 6 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('pong', 4)">
        <div class="game-title">üèì Pong</div>
        <div class="game-description">Classic two-player paddle game!</div>
        <div class="game-cost">Cost: 4 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('asteroids', 5)">
        <div class="game-title">‚òÑÔ∏è Asteroids</div>
        <div class="game-description">Destroy asteroids and survive!</div>
        <div class="game-cost">Cost: 5 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('pacman', 7)">
        <div class="game-title">üëª Pac-Man</div>
        <div class="game-description">Eat dots and avoid ghosts!</div>
        <div class="game-cost">Cost: 7 tokens</div>
      </div>
    </div>
    
    <a class="back-link" href="arcade-instructions.html">üìñ How to Play</a>
    <a class="back-link" href="index.html">‚Üê Back to Main Menu</a>
  </div>

  <div class="container game-area" id="game-area">
    <h2 id="game-title">Game</h2>
    <div style="position: relative;">
      <canvas id="game-canvas" class="game-canvas" width="400" height="400"></canvas>
      <div id="countdown" class="countdown" style="display: none;"></div>
    </div>
    <div class="game-controls">
      <button onclick="pauseGame()" id="pause-btn">Pause</button>
      <button onclick="restartGame()" id="restart-btn">Restart</button>
      <button onclick="exitGame()" id="exit-btn">Exit Game</button>
    </div>
    <div id="game-score">Score: 0</div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls" id="mobile-controls">
      <button class="mobile-btn" onclick="mobileUp()">‚¨ÜÔ∏è</button>
      <button class="mobile-btn" onclick="mobileDown()">‚¨áÔ∏è</button>
      <button class="mobile-btn" onclick="mobileLeft()">‚¨ÖÔ∏è</button>
      <button class="mobile-btn" onclick="mobileRight()">‚û°Ô∏è</button>
      <button class="mobile-btn" onclick="mobileAction()">üéØ</button>
    </div>
  </div>

  <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
  <script src="js/token-manager.js"></script>
  <script>
    let currentUser = null;
    let currentEmail = null;
    let currentGame = null;
    let gameRunning = false;
    let gameScore = 0;
    
    // Game costs
    const gameCosts = {
      snake: 5,
      tetris: 10,
      puzzle: 3,
      flappy: 4,
      breakout: 6,
      pong: 4,
      asteroids: 5,
      pacman: 7
    };

    async function getTokenCount(email) {
      return await window.tokenManager.getTokens(email);
    }
    
    async function setTokenCount(email, count) {
      return await window.tokenManager.setTokens(email, count);
    }
    
    function updateTokenDisplay(email) {
      window.tokenManager.updateTokenDisplay(email);
    }

    async function startGame(gameType, cost) {
      if (!currentEmail) {
        alert('Please sign in to play games!');
        return;
      }
      
      const tokens = await getTokenCount(currentEmail);
      if (tokens < cost) {
        alert(`Not enough tokens! You need ${cost} tokens to play this game.`);
        return;
      }
      
      // Deduct tokens
      await setTokenCount(currentEmail, tokens - cost);
      updateTokenDisplay(currentEmail);
      
      // Start the game
      currentGame = gameType;
      document.getElementById('main-container').style.display = 'none';
      document.getElementById('game-area').classList.add('active');
      document.getElementById('game-title').textContent = getGameTitle(gameType);
      
      initGame(gameType);
    }

    function getGameTitle(gameType) {
      const titles = {
        snake: 'üêç Snake Game',
        tetris: 'üß© Tetris',
        puzzle: 'üß© Number Puzzle',
        flappy: 'üê¶ Flappy Bird',
        breakout: 'üèì Breakout',
        pong: 'üèì Pong',
        asteroids: '‚òÑÔ∏è Asteroids',
        pacman: 'üëª Pac-Man'
      };
      return titles[gameType] || 'Game';
    }

    function startCountdown(callback) {
      const countdownElement = document.getElementById('countdown');
      countdownElement.style.display = 'block';
      
      let count = 3;
      countdownElement.textContent = count;
      
      const countdownInterval = setInterval(() => {
        count--;
        countdownElement.textContent = count;
        
        if (count <= 0) {
          countdownElement.textContent = 'GO!';
          setTimeout(() => {
            countdownElement.style.display = 'none';
            clearInterval(countdownInterval);
            callback();
          }, 1000);
        }
      }, 1000);
    }

    function initGame(gameType) {
      const canvas = document.getElementById('game-canvas');
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Start countdown before initializing game
      startCountdown(() => {
        if (gameType === 'snake') {
          initSnakeGame(ctx, canvas);
        } else if (gameType === 'tetris') {
          initTetrisGame(ctx, canvas);
        } else if (gameType === 'puzzle') {
          initPuzzleGame(ctx, canvas);
        } else if (gameType === 'flappy') {
          initFlappyGame(ctx, canvas);
        } else if (gameType === 'breakout') {
          initBreakoutGame(ctx, canvas);
        } else if (gameType === 'pong') {
          initPongGame(ctx, canvas);
        } else if (gameType === 'asteroids') {
          initAsteroidsGame(ctx, canvas);
        } else if (gameType === 'pacman') {
          initPacmanGame(ctx, canvas);
        }
      });
    }
    
    // Mobile control functions
    function mobileUp() {
      const event = new KeyboardEvent('keydown', { key: 'ArrowUp' });
      document.dispatchEvent(event);
    }
    
    function mobileDown() {
      const event = new KeyboardEvent('keydown', { key: 'ArrowDown' });
      document.dispatchEvent(event);
    }
    
    function mobileLeft() {
      const event = new KeyboardEvent('keydown', { key: 'ArrowLeft' });
      document.dispatchEvent(event);
    }
    
    function mobileRight() {
      const event = new KeyboardEvent('keydown', { key: 'ArrowRight' });
      document.dispatchEvent(event);
    }
    
    function mobileAction() {
      const event = new KeyboardEvent('keydown', { key: ' ' });
      document.dispatchEvent(event);
    }

    function initSnakeGame(ctx, canvas) {
      let snake = [{x: 200, y: 200}];
      let food = {x: 100, y: 100};
      let dx = 10;
      let dy = 0;
      gameScore = 0;
      gameRunning = true;
      
      function drawSnake() {
        ctx.fillStyle = '#4CAF50';
        snake.forEach(segment => {
          ctx.fillRect(segment.x, segment.y, 10, 10);
        });
      }
      
      function drawFood() {
        ctx.fillStyle = '#FF5722';
        ctx.fillRect(food.x, food.y, 10, 10);
      }
      
      function moveSnake() {
        const head = {x: snake[0].x + dx, y: snake[0].y + dy};
        snake.unshift(head);
        
        if (head.x === food.x && head.y === food.y) {
          gameScore += 10;
          food = {
            x: Math.floor(Math.random() * 40) * 10,
            y: Math.floor(Math.random() * 40) * 10
          };
        } else {
          snake.pop();
        }
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        moveSnake();
        drawSnake();
        drawFood();
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        // Check collision with walls or self
        const head = snake[0];
        if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height) {
          gameOver();
          return;
        }
        
        // Check self collision (skip first segment as it's the head)
        for (let i = 1; i < snake.length; i++) {
          if (head.x === snake[i].x && head.y === snake[i].y) {
            gameOver();
            return;
          }
        }
        
        // Speed up as score increases
        const speed = Math.max(50, 150 - Math.floor(gameScore / 10) * 10);
        setTimeout(gameLoop, speed);
      }
      
      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowUp' && dy === 0) { dx = 0; dy = -10; }
        if (e.key === 'ArrowDown' && dy === 0) { dx = 0; dy = 10; }
        if (e.key === 'ArrowLeft' && dx === 0) { dx = -10; dy = 0; }
        if (e.key === 'ArrowRight' && dx === 0) { dx = 10; dy = 0; }
      });
      
      gameLoop();
    }

    function initBreakoutGame(ctx, canvas) {
      const paddle = {
        x: canvas.width / 2 - 50,
        y: canvas.height - 30,
        width: 100,
        height: 10
      };
      
      const ball = {
        x: canvas.width / 2,
        y: canvas.height - 50,
        radius: 5,
        dx: 3,
        dy: -3
      };
      
      let blocks = [];
      let gameScore = 0;
      gameRunning = true;
      
      // Initialize blocks
      function initBlocks() {
        blocks = [];
        const rows = 5;
        const cols = 8;
        const blockWidth = canvas.width / cols;
        const blockHeight = 20;
        
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            blocks.push({
              x: col * blockWidth,
              y: row * blockHeight + 50,
              width: blockWidth - 2,
              height: blockHeight - 2,
              color: `hsl(${row * 60}, 70%, 60%)`
            });
          }
        }
      }
      
      function drawPaddle() {
        ctx.fillStyle = '#1976d2';
        ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
      }
      
      function drawBall() {
        ctx.fillStyle = '#FF5722';
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      function drawBlocks() {
        blocks.forEach(block => {
          ctx.fillStyle = block.color;
          ctx.fillRect(block.x, block.y, block.width, block.height);
        });
      }
      
      function updateBall() {
        ball.x += ball.dx;
        ball.y += ball.dy;
        
        // Wall collision
        if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
          ball.dx = -ball.dx;
        }
        if (ball.y - ball.radius < 0) {
          ball.dy = -ball.dy;
        }
        
        // Paddle collision
        if (ball.y + ball.radius > paddle.y && 
            ball.x > paddle.x && 
            ball.x < paddle.x + paddle.width) {
          ball.dy = -ball.dy;
          // Adjust ball direction based on where it hits the paddle
          const hitPos = (ball.x - paddle.x) / paddle.width;
          ball.dx = (hitPos - 0.5) * 6;
        }
        
        // Block collision
        blocks.forEach((block, index) => {
          if (ball.x + ball.radius > block.x && 
              ball.x - ball.radius < block.x + block.width &&
              ball.y + ball.radius > block.y && 
              ball.y - ball.radius < block.y + block.height) {
            
            ball.dy = -ball.dy;
            blocks.splice(index, 1);
            gameScore += 10;
          }
        });
      }
      
      function updatePaddle() {
        // Mouse/touch control
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          paddle.x = mouseX - paddle.width / 2;
          
          // Keep paddle within bounds
          if (paddle.x < 0) paddle.x = 0;
          if (paddle.x + paddle.width > canvas.width) {
            paddle.x = canvas.width - paddle.width;
          }
        });
        
        // Touch control for mobile
        canvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const touchX = e.touches[0].clientX - rect.left;
          paddle.x = touchX - paddle.width / 2;
          
          // Keep paddle within bounds
          if (paddle.x < 0) paddle.x = 0;
          if (paddle.x + paddle.width > canvas.width) {
            paddle.x = canvas.width - paddle.width;
          }
        });
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        // Clear canvas
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        updateBall();
        updatePaddle();
        
        // Check if ball is lost
        if (ball.y + ball.radius > canvas.height) {
          gameOver();
          return;
        }
        
        // Check if all blocks are destroyed
        if (blocks.length === 0) {
          gameScore += 500; // Bonus for completing level
          setTimeout(() => {
            alert(`Level Complete! Score: ${gameScore}`);
            gameOver();
          }, 500);
          return;
        }
        
        drawBlocks();
        drawPaddle();
        drawBall();
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        requestAnimationFrame(gameLoop);
      }
      
      initBlocks();
      gameLoop();
    }

    function initPongGame(ctx, canvas) {
      const paddleHeight = 80;
      const paddleWidth = 10;
      const ballSize = 8;
      
      const leftPaddle = {
        x: 20,
        y: canvas.height / 2 - paddleHeight / 2,
        width: paddleWidth,
        height: paddleHeight,
        score: 0
      };
      
      const rightPaddle = {
        x: canvas.width - 20 - paddleWidth,
        y: canvas.height / 2 - paddleHeight / 2,
        width: paddleWidth,
        height: paddleHeight,
        score: 0
      };
      
      const ball = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: ballSize,
        dx: 4,
        dy: 4
      };
      
      let gameScore = 0;
      gameRunning = true;
      
      function drawPaddles() {
        ctx.fillStyle = '#1976d2';
        ctx.fillRect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height);
        ctx.fillRect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height);
      }
      
      function drawBall() {
        ctx.fillStyle = '#FF5722';
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      function updateBall() {
        ball.x += ball.dx;
        ball.y += ball.dy;
        
        // Wall collision
        if (ball.y - ball.size < 0 || ball.y + ball.size > canvas.height) {
          ball.dy = -ball.dy;
        }
        
        // Paddle collision
        if (ball.x - ball.size < leftPaddle.x + leftPaddle.width &&
            ball.y > leftPaddle.y && ball.y < leftPaddle.y + leftPaddle.height &&
            ball.x > leftPaddle.x) {
          ball.dx = -ball.dx;
          gameScore += 10;
        }
        
        if (ball.x + ball.size > rightPaddle.x &&
            ball.y > rightPaddle.y && ball.y < rightPaddle.y + rightPaddle.height &&
            ball.x < rightPaddle.x + rightPaddle.width) {
          ball.dx = -ball.dx;
          gameScore += 10;
        }
        
        // Score points
        if (ball.x < 0) {
          rightPaddle.score++;
          resetBall();
        } else if (ball.x > canvas.width) {
          leftPaddle.score++;
          resetBall();
        }
      }
      
      function resetBall() {
        ball.x = canvas.width / 2;
        ball.y = canvas.height / 2;
        ball.dx = Math.random() > 0.5 ? 4 : -4;
        ball.dy = Math.random() > 0.5 ? 4 : -4;
      }
      
      function updatePaddles() {
        // AI for right paddle
        if (ball.y < rightPaddle.y + rightPaddle.height / 2) {
          rightPaddle.y -= 3;
        } else {
          rightPaddle.y += 3;
        }
        
        // Keep paddles in bounds
        if (leftPaddle.y < 0) leftPaddle.y = 0;
        if (leftPaddle.y + leftPaddle.height > canvas.height) leftPaddle.y = canvas.height - leftPaddle.height;
        if (rightPaddle.y < 0) rightPaddle.y = 0;
        if (rightPaddle.y + rightPaddle.height > canvas.height) rightPaddle.y = canvas.height - rightPaddle.height;
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        updateBall();
        updatePaddles();
        
        drawPaddles();
        drawBall();
        
        // Draw center line
        ctx.strokeStyle = '#fff';
        ctx.setLineDash([5, 15]);
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, 0);
        ctx.lineTo(canvas.width / 2, canvas.height);
        ctx.stroke();
        
        // Draw scores
        ctx.fillStyle = '#fff';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(leftPaddle.score, canvas.width / 4, 30);
        ctx.fillText(rightPaddle.score, 3 * canvas.width / 4, 30);
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        requestAnimationFrame(gameLoop);
      }
      
      // Mouse control for left paddle
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseY = e.clientY - rect.top;
        leftPaddle.y = mouseY - leftPaddle.height / 2;
      });
      
      gameLoop();
    }

    function initAsteroidsGame(ctx, canvas) {
      const player = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 20,
        angle: 0,
        velocity: { x: 0, y: 0 }
      };
      
      let asteroids = [];
      let bullets = [];
      let gameScore = 0;
      gameRunning = true;
      
      function createAsteroid() {
        const size = Math.random() * 30 + 20;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 1;
        
        return {
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: size,
          dx: Math.cos(angle) * speed,
          dy: Math.sin(angle) * speed
        };
      }
      
      function initAsteroids() {
        asteroids = [];
        for (let i = 0; i < 8; i++) {
          asteroids.push(createAsteroid());
        }
      }
      
      function drawPlayer() {
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.angle);
        
        ctx.fillStyle = '#4CAF50';
        ctx.beginPath();
        ctx.moveTo(0, -player.size);
        ctx.lineTo(-player.size / 2, player.size / 2);
        ctx.lineTo(player.size / 2, player.size / 2);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      
      function drawAsteroids() {
        ctx.fillStyle = '#FF9800';
        asteroids.forEach(asteroid => {
          ctx.beginPath();
          ctx.arc(asteroid.x, asteroid.y, asteroid.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      
      function drawBullets() {
        ctx.fillStyle = '#FF5722';
        bullets.forEach(bullet => {
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      
      function updatePlayer() {
        player.x += player.velocity.x;
        player.y += player.velocity.y;
        
        // Wrap around screen
        if (player.x < 0) player.x = canvas.width;
        if (player.x > canvas.width) player.x = 0;
        if (player.y < 0) player.y = canvas.height;
        if (player.y > canvas.height) player.y = 0;
      }
      
      function updateAsteroids() {
        asteroids.forEach(asteroid => {
          asteroid.x += asteroid.dx;
          asteroid.y += asteroid.dy;
          
          // Wrap around screen
          if (asteroid.x < 0) asteroid.x = canvas.width;
          if (asteroid.x > canvas.width) asteroid.x = 0;
          if (asteroid.y < 0) asteroid.y = canvas.height;
          if (asteroid.y > canvas.height) asteroid.y = 0;
        });
      }
      
      function updateBullets() {
        bullets.forEach((bullet, index) => {
          bullet.x += bullet.dx;
          bullet.y += bullet.dy;
          
          // Remove bullets that are off screen
          if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
            bullets.splice(index, 1);
          }
        });
      }
      
      function checkCollisions() {
        // Bullet-Asteroid collisions
        bullets.forEach((bullet, bulletIndex) => {
          asteroids.forEach((asteroid, asteroidIndex) => {
            const dx = bullet.x - asteroid.x;
            const dy = bullet.y - asteroid.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < asteroid.size) {
              bullets.splice(bulletIndex, 1);
              asteroids.splice(asteroidIndex, 1);
              gameScore += 50;
              
              // Create smaller asteroids
              if (asteroid.size > 15) {
                for (let i = 0; i < 2; i++) {
                  const newAsteroid = {
                    x: asteroid.x,
                    y: asteroid.y,
                    size: asteroid.size / 2,
                    dx: (Math.random() - 0.5) * 4,
                    dy: (Math.random() - 0.5) * 4
                  };
                  asteroids.push(newAsteroid);
                }
              }
            }
          });
        });
        
        // Player-Asteroid collisions
        asteroids.forEach(asteroid => {
          const dx = player.x - asteroid.x;
          const dy = player.y - asteroid.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < player.size + asteroid.size) {
            gameOver();
          }
        });
      }
      
      function shoot() {
        const bullet = {
          x: player.x + Math.cos(player.angle) * player.size,
          y: player.y + Math.sin(player.angle) * player.size,
          dx: Math.cos(player.angle) * 8,
          dy: Math.sin(player.angle) * 8
        };
        bullets.push(bullet);
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        updatePlayer();
        updateAsteroids();
        updateBullets();
        checkCollisions();
        
        drawPlayer();
        drawAsteroids();
        drawBullets();
        
        if (asteroids.length === 0) {
          initAsteroids();
        }
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        requestAnimationFrame(gameLoop);
      }
      
      // Controls
      document.addEventListener('keydown', (e) => {
        switch(e.key) {
          case 'ArrowLeft':
            player.angle -= 0.1;
            break;
          case 'ArrowRight':
            player.angle += 0.1;
            break;
          case 'ArrowUp':
            player.velocity.x += Math.cos(player.angle) * 0.5;
            player.velocity.y += Math.sin(player.angle) * 0.5;
            break;
          case ' ':
            shoot();
            break;
        }
      });
      
      initAsteroids();
      gameLoop();
    }

    function initPacmanGame(ctx, canvas) {
      const CELL_SIZE = 20;
      const PACMAN_SIZE = 18;
      
      const pacman = {
        x: 1,
        y: 1,
        direction: { x: 1, y: 0 },
        mouthOpen: true
      };
      
      let dots = [];
      let ghosts = [];
      let gameScore = 0;
      gameRunning = true;
      
      // Simple maze layout (1 = wall, 0 = path)
      const maze = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,1],
        [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
        [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,1],
        [1,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1],
        [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,1],
        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
      ];
      
      function initDots() {
        dots = [];
        for (let y = 0; y < maze.length; y++) {
          for (let x = 0; x < maze[y].length; x++) {
            if (maze[y][x] === 0) {
              dots.push({ x, y });
            }
          }
        }
      }
      
      function initGhosts() {
        ghosts = [
          { x: 18, y: 11, color: '#FF0000', direction: { x: -1, y: 0 } },
          { x: 18, y: 1, color: '#FF69B4', direction: { x: -1, y: 0 } }
        ];
      }
      
      function drawMaze() {
        ctx.fillStyle = '#0000FF';
        for (let y = 0; y < maze.length; y++) {
          for (let x = 0; x < maze[y].length; x++) {
            if (maze[y][x] === 1) {
              ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
          }
        }
      }
      
      function drawPacman() {
        ctx.save();
        ctx.translate(pacman.x * CELL_SIZE + CELL_SIZE / 2, pacman.y * CELL_SIZE + CELL_SIZE / 2);
        ctx.rotate(Math.atan2(pacman.direction.y, pacman.direction.x));
        
        ctx.fillStyle = '#FFFF00';
        ctx.beginPath();
        if (pacman.mouthOpen) {
          ctx.arc(0, 0, PACMAN_SIZE / 2, 0.2 * Math.PI, 1.8 * Math.PI);
        } else {
          ctx.arc(0, 0, PACMAN_SIZE / 2, 0, 2 * Math.PI);
        }
        ctx.lineTo(0, 0);
        ctx.fill();
        
        ctx.restore();
      }
      
      function drawDots() {
        ctx.fillStyle = '#FFFFFF';
        dots.forEach(dot => {
          ctx.beginPath();
          ctx.arc(dot.x * CELL_SIZE + CELL_SIZE / 2, dot.y * CELL_SIZE + CELL_SIZE / 2, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      
      function drawGhosts() {
        ghosts.forEach(ghost => {
          ctx.fillStyle = ghost.color;
          ctx.beginPath();
          ctx.arc(ghost.x * CELL_SIZE + CELL_SIZE / 2, ghost.y * CELL_SIZE + CELL_SIZE / 2, PACMAN_SIZE / 2, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      
      function updatePacman() {
        const newX = pacman.x + pacman.direction.x;
        const newY = pacman.y + pacman.direction.y;
        
        if (newX >= 0 && newX < maze[0].length && newY >= 0 && newY < maze.length && maze[newY][newX] === 0) {
          pacman.x = newX;
          pacman.y = newY;
        }
        
        // Animate mouth
        pacman.mouthOpen = !pacman.mouthOpen;
      }
      
      function updateGhosts() {
        ghosts.forEach(ghost => {
          const newX = ghost.x + ghost.direction.x;
          const newY = ghost.y + ghost.direction.y;
          
          if (newX >= 0 && newX < maze[0].length && newY >= 0 && newY < maze.length && maze[newY][newX] === 0) {
            ghost.x = newX;
            ghost.y = newY;
          } else {
            // Change direction randomly
            const directions = [{ x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }];
            ghost.direction = directions[Math.floor(Math.random() * directions.length)];
          }
        });
      }
      
      function checkCollisions() {
        // Pacman-Dot collisions
        dots.forEach((dot, index) => {
          if (pacman.x === dot.x && pacman.y === dot.y) {
            dots.splice(index, 1);
            gameScore += 10;
          }
        });
        
        // Pacman-Ghost collisions
        ghosts.forEach(ghost => {
          if (pacman.x === ghost.x && pacman.y === ghost.y) {
            gameOver();
          }
        });
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        updatePacman();
        updateGhosts();
        checkCollisions();
        
        drawMaze();
        drawDots();
        drawPacman();
        drawGhosts();
        
        if (dots.length === 0) {
          gameScore += 500; // Bonus for completing level
          setTimeout(() => {
            alert(`Level Complete! Score: ${gameScore}`);
            gameOver();
          }, 500);
          return;
        }
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        setTimeout(gameLoop, 200);
      }
      
      // Controls
      document.addEventListener('keydown', (e) => {
        switch(e.key) {
          case 'ArrowLeft':
            pacman.direction = { x: -1, y: 0 };
            break;
          case 'ArrowRight':
            pacman.direction = { x: 1, y: 0 };
            break;
          case 'ArrowUp':
            pacman.direction = { x: 0, y: -1 };
            break;
          case 'ArrowDown':
            pacman.direction = { x: 0, y: 1 };
            break;
        }
      });
      
      initDots();
      initGhosts();
      gameLoop();
    }

    function initTetrisGame(ctx, canvas) {
      const BLOCK_SIZE = 20;
      const COLS = canvas.width / BLOCK_SIZE;
      const ROWS = canvas.height / BLOCK_SIZE;
      
      let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
      let currentPiece = null;
      let gameScore = 0;
      gameRunning = true;
      
      // Tetris pieces
      const PIECES = [
        [[1,1,1,1]], // I
        [[1,1],[1,1]], // O
        [[1,1,1],[0,1,0]], // T
        [[1,1,1],[1,0,0]], // L
        [[1,1,1],[0,0,1]], // J
        [[1,1,0],[0,1,1]], // S
        [[0,1,1],[1,1,0]]  // Z
      ];
      
      function createPiece() {
        const piece = PIECES[Math.floor(Math.random() * PIECES.length)];
        return {
          shape: piece,
          x: Math.floor(COLS / 2) - Math.floor(piece[0].length / 2),
          y: 0
        };
      }
      
      function drawBoard() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            if (board[y][x]) {
              ctx.fillStyle = '#2196F3';
              ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            }
          }
        }
      }
      
      function drawPiece(piece) {
        ctx.fillStyle = '#FF5722';
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              ctx.fillRect((piece.x + x) * BLOCK_SIZE, (piece.y + y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            }
          }
        }
      }
      
      function isValid(piece, dx = 0, dy = 0) {
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              const newX = piece.x + x + dx;
              const newY = piece.y + y + dy;
              if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX])) {
                return false;
              }
            }
          }
        }
        return true;
      }
      
      function placePiece(piece) {
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              board[piece.y + y][piece.x + x] = 1;
            }
          }
        }
      }
      
      function clearLines() {
        let linesCleared = 0;
        for (let y = ROWS - 1; y >= 0; y--) {
          if (board[y].every(cell => cell)) {
            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            linesCleared++;
            y++;
          }
        }
        if (linesCleared > 0) {
          gameScore += linesCleared * 100;
        }
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        if (!currentPiece) {
          currentPiece = createPiece();
          // Check if the new piece can be placed
          if (!isValid(currentPiece)) {
            // Try to move the piece down if it's stuck at the top
            currentPiece.y += 1;
            if (!isValid(currentPiece)) {
              gameOver();
              return;
            }
          }
        }
        
        if (isValid(currentPiece, 0, 1)) {
          currentPiece.y++;
        } else {
          placePiece(currentPiece);
          clearLines();
          currentPiece = null;
        }
        
        drawBoard();
        if (currentPiece) {
          drawPiece(currentPiece);
        }
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        setTimeout(gameLoop, 500);
      }
      
      document.addEventListener('keydown', (e) => {
        if (!currentPiece) return;
        
        if (e.key === 'ArrowLeft' && isValid(currentPiece, -1, 0)) {
          currentPiece.x--;
        } else if (e.key === 'ArrowRight' && isValid(currentPiece, 1, 0)) {
          currentPiece.x++;
        } else if (e.key === 'ArrowDown' && isValid(currentPiece, 0, 1)) {
          currentPiece.y++;
        } else if (e.key === 'ArrowUp') {
          // Rotate piece
          const rotated = [];
          for (let x = 0; x < currentPiece.shape[0].length; x++) {
            rotated[x] = [];
            for (let y = currentPiece.shape.length - 1; y >= 0; y--) {
              rotated[x][currentPiece.shape.length - 1 - y] = currentPiece.shape[y][x];
            }
          }
          const originalShape = currentPiece.shape;
          currentPiece.shape = rotated;
          if (!isValid(currentPiece)) {
            currentPiece.shape = originalShape;
          }
        }
      });
      
      gameLoop();
    }

    function initPuzzleGame(ctx, canvas) {
      const TILE_SIZE = 80;
      const GRID_SIZE = 3;
      const BOARD_SIZE = TILE_SIZE * GRID_SIZE;
      
      let tiles = [];
      let emptyPos = { x: GRID_SIZE - 1, y: GRID_SIZE - 1 };
      let gameScore = 0;
      let moves = 0;
      gameRunning = true;
      
      // Initialize tiles
      function initTiles() {
        tiles = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE - 1; i++) {
          tiles.push(i + 1);
        }
        tiles.push(0); // Empty tile
        shuffleTiles();
      }
      
      function shuffleTiles() {
        for (let i = tiles.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
        }
        // Find empty position
        const emptyIndex = tiles.indexOf(0);
        emptyPos.x = emptyIndex % GRID_SIZE;
        emptyPos.y = Math.floor(emptyIndex / GRID_SIZE);
      }
      
      function drawTiles() {
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            const index = y * GRID_SIZE + x;
            const value = tiles[index];
            
            if (value !== 0) {
              const tileX = x * TILE_SIZE + 10;
              const tileY = y * TILE_SIZE + 10;
              
              // Draw tile background
              ctx.fillStyle = '#9C27B0';
              ctx.fillRect(tileX, tileY, TILE_SIZE - 20, TILE_SIZE - 20);
              
              // Draw number
              ctx.fillStyle = '#fff';
              ctx.font = 'bold 24px Arial';
              ctx.textAlign = 'center';
              ctx.fillText(value.toString(), tileX + (TILE_SIZE - 20) / 2, tileY + (TILE_SIZE - 20) / 2 + 8);
            }
          }
        }
      }
      
      function canMove(x, y) {
        return (Math.abs(x - emptyPos.x) === 1 && y === emptyPos.y) ||
               (Math.abs(y - emptyPos.y) === 1 && x === emptyPos.x);
      }
      
      function moveTile(x, y) {
        if (!canMove(x, y)) return false;
        
        const fromIndex = y * GRID_SIZE + x;
        const toIndex = emptyPos.y * GRID_SIZE + emptyPos.x;
        
        // Swap tiles
        [tiles[fromIndex], tiles[toIndex]] = [tiles[toIndex], tiles[fromIndex]];
        
        // Update empty position
        emptyPos.x = x;
        emptyPos.y = y;
        
        moves++;
        return true;
      }
      
      function isSolved() {
        for (let i = 0; i < tiles.length - 1; i++) {
          if (tiles[i] !== i + 1) return false;
        }
        return tiles[tiles.length - 1] === 0;
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        drawTiles();
        
        if (isSolved()) {
          gameScore = Math.max(1000 - moves * 10, 100);
          setTimeout(() => {
            alert(`Puzzle Solved! Score: ${gameScore}`);
            gameOver();
          }, 500);
        }
        
        document.getElementById('game-score').textContent = `Moves: ${moves}`;
      }
      
      // Mouse/touch controls
      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
        const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);
        
        if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
          if (moveTile(x, y)) {
            gameLoop();
          }
        }
      });
      
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        let moved = false;
        
        switch(e.key) {
          case 'ArrowUp':
            moved = moveTile(emptyPos.x, emptyPos.y + 1);
            break;
          case 'ArrowDown':
            moved = moveTile(emptyPos.x, emptyPos.y - 1);
            break;
          case 'ArrowLeft':
            moved = moveTile(emptyPos.x + 1, emptyPos.y);
            break;
          case 'ArrowRight':
            moved = moveTile(emptyPos.x - 1, emptyPos.y);
            break;
        }
        
        if (moved) {
          gameLoop();
        }
      });
      
      initTiles();
      gameLoop();
    }

    function initFlappyGame(ctx, canvas) {
      const bird = {
        x: 50,
        y: canvas.height / 2,
        velocity: 0,
        size: 20
      };
      
      let pipes = [];
      let gameScore = 0;
      gameRunning = true;
      
      function createPipe() {
        const gap = 150;
        const gapY = Math.random() * (canvas.height - gap - 100) + 50;
        return {
          x: canvas.width,
          gapY: gapY,
          gapHeight: gap,
          width: 50
        };
      }
      
      function drawBird() {
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.arc(bird.x, bird.y, bird.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw eye
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(bird.x + 8, bird.y - 5, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      function drawPipes() {
        ctx.fillStyle = '#4CAF50';
        pipes.forEach(pipe => {
          // Top pipe
          ctx.fillRect(pipe.x, 0, pipe.width, pipe.gapY);
          // Bottom pipe
          ctx.fillRect(pipe.x, pipe.gapY + pipe.gapHeight, pipe.width, canvas.height - pipe.gapY - pipe.gapHeight);
        });
      }
      
      function updateBird() {
        bird.velocity += 0.8; // Gravity
        bird.y += bird.velocity;
      }
      
      function updatePipes() {
        pipes.forEach(pipe => {
          pipe.x -= 3;
        });
        
        // Remove pipes that are off screen
        pipes = pipes.filter(pipe => pipe.x + pipe.width > 0);
        
        // Add new pipes
        if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 300) {
          pipes.push(createPipe());
        }
      }
      
      function checkCollision() {
        // Check wall collision
        if (bird.y - bird.size < 0 || bird.y + bird.size > canvas.height) {
          return true;
        }
        
        // Check pipe collision
        return pipes.some(pipe => {
          return bird.x + bird.size > pipe.x && 
                 bird.x - bird.size < pipe.x + pipe.width &&
                 (bird.y - bird.size < pipe.gapY || bird.y + bird.size > pipe.gapY + pipe.gapHeight);
        });
      }
      
      function checkScore() {
        pipes.forEach(pipe => {
          if (pipe.x + pipe.width < bird.x && !pipe.passed) {
            gameScore++;
            pipe.passed = true;
          }
        });
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        // Clear canvas
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        updateBird();
        updatePipes();
        checkScore();
        
        drawPipes();
        drawBird();
        
        if (checkCollision()) {
          gameOver();
          return;
        }
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        requestAnimationFrame(gameLoop);
      }
      
      // Controls
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          bird.velocity = -12;
        }
      });
      
      canvas.addEventListener('click', () => {
        bird.velocity = -12;
      });
      
      // Touch controls for mobile
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        bird.velocity = -12;
      });
      
      gameLoop();
    }

    function pauseGame() {
      gameRunning = !gameRunning;
      document.getElementById('pause-btn').textContent = gameRunning ? 'Pause' : 'Resume';
      if (gameRunning) {
        initGame(currentGame);
      }
    }

    function restartGame() {
      gameScore = 0;
      initGame(currentGame);
    }

    function exitGame() {
      gameRunning = false;
      document.getElementById('game-area').classList.remove('active');
      document.getElementById('main-container').style.display = 'block';
      currentGame = null;
    }

    function gameOver() {
      gameRunning = false;
      alert(`Game Over! Final Score: ${gameScore}`);
      exitGame();
    }

    // Netlify Identity integration
    function checkAuth() {
      const user = netlifyIdentity.currentUser();
      if (user) {
        currentUser = user;
        currentEmail = user.email;
        document.getElementById('user-email').textContent = 'Logged in as: ' + user.email;
        updateTokenDisplay(user.email);
      } else {
        currentUser = null;
        currentEmail = null;
        document.getElementById('user-email').textContent = 'Not signed in.';
      }
    }

    document.addEventListener("DOMContentLoaded", function() {
      if (window.netlifyIdentity) {
        netlifyIdentity.on("login", user => {
          currentUser = user;
          currentEmail = user.email;
          checkAuth();
        });
        netlifyIdentity.on("logout", () => {
          currentUser = null;
          currentEmail = null;
          checkAuth();
        });
        netlifyIdentity.on("init", () => {
          checkAuth();
        });
        netlifyIdentity.init();
      }
      checkAuth();
    });
  </script>
</body>
</html> 