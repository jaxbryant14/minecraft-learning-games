<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arcade Games</title>
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0; 
      padding: 0; 
      min-height: 100vh;
    }
    .container { 
      max-width: 600px; 
      margin: 40px auto; 
      background: #fff; 
      padding: 2.5em; 
      border-radius: 16px; 
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      text-align: center;
    }
    h2 { 
      text-align: center; 
      color: #333;
      margin-bottom: 1.5em;
      font-size: 2.2em;
    }
    .token-info { 
      text-align: center; 
      margin-bottom: 1.5em;
      font-size: 1.2em;
      font-weight: bold;
      color: #1976d2;
    }
    .user-email { 
      text-align: center; 
      margin-bottom: 1em;
      color: #666;
      font-style: italic;
    }
    .game-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 2em 0;
    }
    .game-card {
      background: linear-gradient(45deg, #f8f9fa, #e9ecef);
      border-radius: 12px;
      padding: 1.5em;
      border: 2px solid #e0e0e0;
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: pointer;
    }
    .game-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
      border-color: #1976d2;
    }
    .game-card.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .game-title {
      font-size: 1.3em;
      font-weight: bold;
      color: #333;
      margin-bottom: 0.5em;
    }
    .game-description {
      color: #666;
      margin-bottom: 1em;
      font-size: 0.9em;
    }
    .game-cost {
      color: #1976d2;
      font-weight: bold;
      font-size: 1.1em;
    }
    .back-link { 
      display: block; 
      text-align: center; 
      
      margin-top: 2em;
      color: #1976d2;
      text-decoration: none;
      font-weight: bold;
    }
    .back-link:hover {
      text-decoration: underline;
    }
    .game-area {
      display: none;
      margin-top: 2em;
    }
    .game-area.active {
      display: block;
    }
    .game-canvas {
      border: 2px solid #333;
      border-radius: 8px;
      background: #000;
      margin: 1em auto;
      max-width: 100%;
      height: auto;
    }
    
    .countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4em;
      font-weight: bold;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      z-index: 1000;
    }
    
    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
    }
    
    .mobile-btn {
      width: 60px;
      height: 60px;
      margin: 5px;
      border: none;
      border-radius: 50%;
      background: rgba(25, 118, 210, 0.8);
      color: white;
      font-size: 1.5em;
      cursor: pointer;
    }
    
    @media (max-width: 768px) {
      .mobile-controls {
        display: flex;
      }
      .game-canvas {
        width: 100%;
        max-width: 400px;
      }
      
      .container {
        padding: 1rem;
      }
      
      .game-grid {
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1rem;
      }
    }

    @media (max-width: 480px) {
      .container {
        padding: 0.5rem;
      }
      
      h2 {
        font-size: 1.5rem;
      }
      
      .game-card {
        padding: 0.75rem;
      }
      
      .game-title {
        font-size: 1rem;
      }
      
      .game-cost {
        font-size: 0.8rem;
      }
      
      .game-grid {
        grid-template-columns: 1fr;
        gap: 0.75rem;
      }
    }

    @media (min-height: 800px) {
      .container {
        min-height: calc(100vh - 120px);
      }
    }

    @media (max-height: 600px) {
      .container {
        padding: 1rem;
      }
      
      .game-grid {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 0.75rem;
      }
    }
    .game-controls {
      margin: 1em 0;
    }
    button { 
      padding: 0.8em 1.5em; 
      background: linear-gradient(45deg, #1976d2, #42a5f5); 
      color: #fff; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer; 
      margin: 0.5em;
      font-size: 1em;
      font-weight: bold;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover { 
      background: linear-gradient(45deg, #0d47a1, #1976d2);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
  </style>
</head>
<body>
  <div class="container" id="main-container">
    <h2>üéÆ Arcade Games</h2>
    <div class="user-email" id="user-email"></div>
    <div class="token-info">Tokens: <span id="token-count"></span></div>
    
    <div class="game-grid">
      <div class="game-card" onclick="startGame('snake', 5)">
        <div class="game-title">üêç Snake Game</div>
        <div class="game-description">Classic snake game. Eat food to grow longer!</div>
        <div class="game-cost">Cost: 5 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('tetris', 10)">
        <div class="game-title">üß© Tetris</div>
        <div class="game-description">Stack blocks and clear lines!</div>
        <div class="game-cost">Cost: 10 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('puzzle', 3)">
        <div class="game-title">üß© Number Puzzle</div>
        <div class="game-description">Slide tiles to arrange numbers in order!</div>
        <div class="game-cost">Cost: 3 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('flappy', 4)">
        <div class="game-title">üê¶ Flappy Bird</div>
        <div class="game-description">Navigate through pipes with spacebar!</div>
        <div class="game-cost">Cost: 4 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('breakout', 6)">
        <div class="game-title">üèì Breakout</div>
        <div class="game-description">Break all the blocks with your paddle!</div>
        <div class="game-cost">Cost: 6 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('pong', 4)">
        <div class="game-title">üèì Pong</div>
        <div class="game-description">Classic two-player paddle game!</div>
        <div class="game-cost">Cost: 4 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('asteroids', 5)">
        <div class="game-title">‚òÑÔ∏è Asteroids</div>
        <div class="game-description">Destroy asteroids and survive!</div>
        <div class="game-cost">Cost: 5 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('pacman', 7)">
        <div class="game-title">üëª Pac-Man</div>
        <div class="game-description">Eat dots and avoid ghosts!</div>
        <div class="game-cost">Cost: 7 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('hair', 3)">
        <div class="game-title">üíá‚Äç‚ôÄÔ∏è Hair Styling</div>
        <div class="game-description">Style hair with scissors and styling tools!</div>
        <div class="game-cost">Cost: 3 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('zombie', 5)">
        <div class="game-title">‚öîÔ∏è Zombie Slasher</div>
        <div class="game-description">Slash cartoon zombies with your sword!</div>
        <div class="game-cost">Cost: 5 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('cooking', 4)">
        <div class="game-title">üë®‚Äçüç≥ Cooking Master</div>
        <div class="game-description">Cook delicious meals in the kitchen!</div>
        <div class="game-cost">Cost: 4 tokens</div>
      </div>
      
      <div class="game-card" onclick="startGame('racing', 6)">
        <div class="game-title">üèéÔ∏è Speed Racing</div>
        <div class="game-description">Race through obstacles at high speed!</div>
        <div class="game-cost">Cost: 6 tokens</div>
      </div>
    </div>
    
    <a class="back-link" href="arcade-instructions.html">üìñ How to Play</a>
    <a class="back-link" href="index.html">‚Üê Back to Main Menu</a>
  </div>

  <div class="container game-area" id="game-area">
    <h2 id="game-title">Game</h2>
    <div style="position: relative;">
      <canvas id="game-canvas" class="game-canvas" width="400" height="400"></canvas>
      <div id="countdown" class="countdown" style="display: none;"></div>
    </div>
    <div class="game-controls">
      <button onclick="pauseGame()" id="pause-btn">Pause</button>
      <button onclick="restartGame()" id="restart-btn">Restart</button>
      <button onclick="exitGame()" id="exit-btn">Exit Game</button>
    </div>
    <div id="game-score">Score: 0</div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls" id="mobile-controls">
      <button class="mobile-btn" onclick="mobileUp()">‚¨ÜÔ∏è</button>
      <button class="mobile-btn" onclick="mobileDown()">‚¨áÔ∏è</button>
      <button class="mobile-btn" onclick="mobileLeft()">‚¨ÖÔ∏è</button>
      <button class="mobile-btn" onclick="mobileRight()">‚û°Ô∏è</button>
      <button class="mobile-btn" onclick="mobileAction()">üéØ</button>
    </div>
  </div>

  <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
  <script src="js/token-manager.js"></script>
  <script>
    let currentUser = null;
    let currentEmail = null;
    let currentGame = null;
    let gameRunning = false;
    let gameScore = 0;
    
    // Game costs
    const gameCosts = {
      snake: 5,
      tetris: 10,
      puzzle: 3,
      flappy: 4,
      breakout: 6,
      pong: 4,
      asteroids: 5,
      pacman: 7
    };

    async function getTokenCount(email) {
      try {
        const tokens = await window.tokenManager.getTokens(email);
        console.log('üîÑ Retrieved tokens for', email, ':', tokens);
        return tokens;
      } catch (error) {
        console.error('‚ùå Error getting tokens:', error);
        return 0;
      }
    }
    
    async function setTokenCount(email, count) {
      try {
        const result = await window.tokenManager.setTokens(email, count);
        console.log('üîÑ Set tokens for', email, 'to:', count, 'Result:', result);
        return result;
      } catch (error) {
        console.error('‚ùå Error setting tokens:', error);
        return count;
      }
    }
    
    function updateTokenDisplay(email) {
      window.tokenManager.updateTokenDisplay(email);
    }

    async function startGame(gameType, cost) {
      if (!currentEmail) {
        alert('Please sign in to play games!');
        return;
      }
      
      try {
        const tokens = await getTokenCount(currentEmail);
        console.log('üîÑ Current tokens:', tokens, 'Cost:', cost);
        
        if (tokens < cost) {
          alert(`Not enough tokens! You need ${cost} tokens to play this game.`);
          return;
        }
        
        // Deduct tokens
        const newTokens = tokens - cost;
        console.log('üîÑ Deducting tokens:', tokens, '-', cost, '=', newTokens);
        await setTokenCount(currentEmail, newTokens);
        updateTokenDisplay(currentEmail);
        
        // Start the game
        currentGame = gameType;
        document.getElementById('main-container').style.display = 'none';
        document.getElementById('game-area').classList.add('active');
        document.getElementById('game-title').textContent = getGameTitle(gameType);
        
        initGame(gameType);
      } catch (error) {
        console.error('‚ùå Error starting game:', error);
        alert('Error starting game. Please try again.');
      }
    }

    function getGameTitle(gameType) {
      const titles = {
        snake: 'üêç Snake Game',
        tetris: 'üß© Tetris',
        puzzle: 'üß© Number Puzzle',
        flappy: 'üê¶ Flappy Bird',
        breakout: 'üèì Breakout',
        pong: 'üèì Pong',
        asteroids: '‚òÑÔ∏è Asteroids',
        pacman: 'üëª Pac-Man'
      };
      return titles[gameType] || 'Game';
    }

    function startCountdown(callback) {
      const countdownElement = document.getElementById('countdown');
      countdownElement.style.display = 'block';
      
      let count = 3;
      countdownElement.textContent = count;
      
      const countdownInterval = setInterval(() => {
        count--;
        countdownElement.textContent = count;
        
        if (count <= 0) {
          countdownElement.textContent = 'GO!';
          setTimeout(() => {
            countdownElement.style.display = 'none';
            clearInterval(countdownInterval);
            callback();
          }, 1000);
        }
      }, 1000);
    }

    function initGame(gameType) {
      const canvas = document.getElementById('game-canvas');
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Start countdown before initializing game
      startCountdown(() => {
        if (gameType === 'snake') {
          initSnakeGame(ctx, canvas);
        } else if (gameType === 'tetris') {
          initTetrisGame(ctx, canvas);
        } else if (gameType === 'puzzle') {
          initPuzzleGame(ctx, canvas);
        } else if (gameType === 'flappy') {
          initFlappyGame(ctx, canvas);
        } else if (gameType === 'breakout') {
          initBreakoutGame(ctx, canvas);
        } else if (gameType === 'pong') {
          initPongGame(ctx, canvas);
        } else if (gameType === 'asteroids') {
          initAsteroidsGame(ctx, canvas);
        } else if (gameType === 'pacman') {
          initPacmanGame(ctx, canvas);
        } else if (gameType === 'hair') {
          initHairGame(ctx, canvas);
        } else if (gameType === 'zombie') {
          initZombieGame(ctx, canvas);
        } else if (gameType === 'cooking') {
          initCookingGame(ctx, canvas);
        } else if (gameType === 'racing') {
          initRacingGame(ctx, canvas);
        }
      });
    }
    
    // Mobile control functions
    function mobileUp() {
      const event = new KeyboardEvent('keydown', { key: 'ArrowUp' });
      document.dispatchEvent(event);
    }
    
    function mobileDown() {
      const event = new KeyboardEvent('keydown', { key: 'ArrowDown' });
      document.dispatchEvent(event);
    }
    
    function mobileLeft() {
      const event = new KeyboardEvent('keydown', { key: 'ArrowLeft' });
      document.dispatchEvent(event);
    }
    
    function mobileRight() {
      const event = new KeyboardEvent('keydown', { key: 'ArrowRight' });
      document.dispatchEvent(event);
    }
    
    function mobileAction() {
      const event = new KeyboardEvent('keydown', { key: ' ' });
      document.dispatchEvent(event);
    }

    function initSnakeGame(ctx, canvas) {
      // Clear any existing game loops
      if (window.snakeGameLoopId) {
        cancelAnimationFrame(window.snakeGameLoopId);
        window.snakeGameLoopId = null;
      }
      
      let snake = [{x: 200, y: 200}];
      let food = {x: 100, y: 100};
      let dx = 10;
      let dy = 0;
      gameScore = 0;
      gameRunning = true;
      let lastTime = 0;
      const gameSpeed = 150; // milliseconds between moves
      
      function drawSnake() {
        ctx.fillStyle = '#4CAF50';
        snake.forEach(segment => {
          ctx.fillRect(segment.x, segment.y, 10, 10);
        });
      }
      
      function drawFood() {
        ctx.fillStyle = '#FF5722';
        ctx.fillRect(food.x, food.y, 10, 10);
      }
      
      function generateFood() {
        let newFood;
        do {
          newFood = {
            x: Math.floor(Math.random() * 40) * 10,
            y: Math.floor(Math.random() * 40) * 10
          };
        } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
        return newFood;
      }
      
      function moveSnake() {
        const head = {x: snake[0].x + dx, y: snake[0].y + dy};
        snake.unshift(head);
        
        if (head.x === food.x && head.y === food.y) {
          gameScore += 10;
          food = generateFood();
        } else {
          snake.pop();
        }
      }
      
      function checkCollision() {
        const head = snake[0];
        
        // Wall collision
        if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height) {
          return true;
        }
        
        // Self collision (skip first segment as it's the head)
        for (let i = 1; i < snake.length; i++) {
          if (head.x === snake[i].x && head.y === snake[i].y) {
            return true;
          }
        }
        
        return false;
      }
      
      function gameLoop(currentTime) {
        if (!gameRunning) {
          if (window.snakeGameLoopId) {
            cancelAnimationFrame(window.snakeGameLoopId);
            window.snakeGameLoopId = null;
          }
          return;
        }
        
        // Only move snake at specific intervals
        if (currentTime - lastTime > gameSpeed) {
          // Clear canvas completely
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          moveSnake();
          
          if (checkCollision()) {
            gameOver();
            return;
          }
          
          drawSnake();
          drawFood();
          
          document.getElementById('game-score').textContent = `Score: ${gameScore}`;
          
          lastTime = currentTime;
        }
        
        window.snakeGameLoopId = requestAnimationFrame(gameLoop);
      }
      
      // Clear any existing event listeners
      const newKeyHandler = (e) => {
        if (e.key === 'ArrowUp' && dy === 0) { dx = 0; dy = -10; }
        if (e.key === 'ArrowDown' && dy === 0) { dx = 0; dy = 10; }
        if (e.key === 'ArrowLeft' && dx === 0) { dx = -10; dy = 0; }
        if (e.key === 'ArrowRight' && dx === 0) { dx = 10; dy = 0; }
      };
      
      document.removeEventListener('keydown', newKeyHandler);
      document.addEventListener('keydown', newKeyHandler);
      
      gameLoop();
    }

    function initBreakoutGame(ctx, canvas) {
      const paddle = {
        x: canvas.width / 2 - 50,
        y: canvas.height - 30,
        width: 100,
        height: 10
      };
      
      const ball = {
        x: canvas.width / 2,
        y: canvas.height - 50,
        radius: 5,
        dx: 3,
        dy: -3
      };
      
      let blocks = [];
      let gameScore = 0;
      gameRunning = true;
      
      // Initialize blocks
      function initBlocks() {
        blocks = [];
        const rows = 5;
        const cols = 8;
        const blockWidth = canvas.width / cols;
        const blockHeight = 20;
        
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            blocks.push({
              x: col * blockWidth,
              y: row * blockHeight + 50,
              width: blockWidth - 2,
              height: blockHeight - 2,
              color: `hsl(${row * 60}, 70%, 60%)`
            });
          }
        }
      }
      
      function drawPaddle() {
        ctx.fillStyle = '#1976d2';
        ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
      }
      
      function drawBall() {
        ctx.fillStyle = '#FF5722';
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      function drawBlocks() {
        blocks.forEach(block => {
          ctx.fillStyle = block.color;
          ctx.fillRect(block.x, block.y, block.width, block.height);
        });
      }
      
      function updateBall() {
        ball.x += ball.dx;
        ball.y += ball.dy;
        
        // Wall collision
        if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
          ball.dx = -ball.dx;
        }
        if (ball.y - ball.radius < 0) {
          ball.dy = -ball.dy;
        }
        
        // Paddle collision
        if (ball.y + ball.radius > paddle.y && 
            ball.x > paddle.x && 
            ball.x < paddle.x + paddle.width) {
          ball.dy = -ball.dy;
          // Adjust ball direction based on where it hits the paddle
          const hitPos = (ball.x - paddle.x) / paddle.width;
          ball.dx = (hitPos - 0.5) * 6;
        }
        
        // Block collision
        blocks.forEach((block, index) => {
          if (ball.x + ball.radius > block.x && 
              ball.x - ball.radius < block.x + block.width &&
              ball.y + ball.radius > block.y && 
              ball.y - ball.radius < block.y + block.height) {
            
            ball.dy = -ball.dy;
            blocks.splice(index, 1);
            gameScore += 10;
          }
        });
      }
      
      function updatePaddle() {
        // Mouse/touch control
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          paddle.x = mouseX - paddle.width / 2;
          
          // Keep paddle within bounds
          if (paddle.x < 0) paddle.x = 0;
          if (paddle.x + paddle.width > canvas.width) {
            paddle.x = canvas.width - paddle.width;
          }
        });
        
        // Touch control for mobile
        canvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const touchX = e.touches[0].clientX - rect.left;
          paddle.x = touchX - paddle.width / 2;
          
          // Keep paddle within bounds
          if (paddle.x < 0) paddle.x = 0;
          if (paddle.x + paddle.width > canvas.width) {
            paddle.x = canvas.width - paddle.width;
          }
        });
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        // Clear canvas
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        updateBall();
        updatePaddle();
        
        // Check if ball is lost
        if (ball.y + ball.radius > canvas.height) {
          gameOver();
          return;
        }
        
        // Check if all blocks are destroyed
        if (blocks.length === 0) {
          gameScore += 500; // Bonus for completing level
          setTimeout(() => {
            alert(`Level Complete! Score: ${gameScore}`);
            gameOver();
          }, 500);
          return;
        }
        
        drawBlocks();
        drawPaddle();
        drawBall();
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        requestAnimationFrame(gameLoop);
      }
      
      initBlocks();
      gameLoop();
    }

    function initPongGame(ctx, canvas) {
      const paddleHeight = 80;
      const paddleWidth = 10;
      const ballSize = 8;
      
      const leftPaddle = {
        x: 20,
        y: canvas.height / 2 - paddleHeight / 2,
        width: paddleWidth,
        height: paddleHeight,
        score: 0
      };
      
      const rightPaddle = {
        x: canvas.width - 20 - paddleWidth,
        y: canvas.height / 2 - paddleHeight / 2,
        width: paddleWidth,
        height: paddleHeight,
        score: 0
      };
      
      const ball = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: ballSize,
        dx: 4,
        dy: 4
      };
      
      let gameScore = 0;
      gameRunning = true;
      
      function drawPaddles() {
        ctx.fillStyle = '#1976d2';
        ctx.fillRect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height);
        ctx.fillRect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height);
      }
      
      function drawBall() {
        ctx.fillStyle = '#FF5722';
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      function updateBall() {
        ball.x += ball.dx;
        ball.y += ball.dy;
        
        // Wall collision
        if (ball.y - ball.size < 0 || ball.y + ball.size > canvas.height) {
          ball.dy = -ball.dy;
        }
        
        // Paddle collision
        if (ball.x - ball.size < leftPaddle.x + leftPaddle.width &&
            ball.y > leftPaddle.y && ball.y < leftPaddle.y + leftPaddle.height &&
            ball.x > leftPaddle.x) {
          ball.dx = -ball.dx;
          gameScore += 10;
        }
        
        if (ball.x + ball.size > rightPaddle.x &&
            ball.y > rightPaddle.y && ball.y < rightPaddle.y + rightPaddle.height &&
            ball.x < rightPaddle.x + rightPaddle.width) {
          ball.dx = -ball.dx;
          gameScore += 10;
        }
        
        // Score points
        if (ball.x < 0) {
          rightPaddle.score++;
          resetBall();
        } else if (ball.x > canvas.width) {
          leftPaddle.score++;
          resetBall();
        }
      }
      
      function resetBall() {
        ball.x = canvas.width / 2;
        ball.y = canvas.height / 2;
        ball.dx = Math.random() > 0.5 ? 4 : -4;
        ball.dy = Math.random() > 0.5 ? 4 : -4;
      }
      
      function updatePaddles() {
        // AI for right paddle
        if (ball.y < rightPaddle.y + rightPaddle.height / 2) {
          rightPaddle.y -= 3;
        } else {
          rightPaddle.y += 3;
        }
        
        // Keep paddles in bounds
        if (leftPaddle.y < 0) leftPaddle.y = 0;
        if (leftPaddle.y + leftPaddle.height > canvas.height) leftPaddle.y = canvas.height - leftPaddle.height;
        if (rightPaddle.y < 0) rightPaddle.y = 0;
        if (rightPaddle.y + rightPaddle.height > canvas.height) rightPaddle.y = canvas.height - rightPaddle.height;
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        updateBall();
        updatePaddles();
        
        drawPaddles();
        drawBall();
        
        // Draw center line
        ctx.strokeStyle = '#fff';
        ctx.setLineDash([5, 15]);
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, 0);
        ctx.lineTo(canvas.width / 2, canvas.height);
        ctx.stroke();
        
        // Draw scores
        ctx.fillStyle = '#fff';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(leftPaddle.score, canvas.width / 4, 30);
        ctx.fillText(rightPaddle.score, 3 * canvas.width / 4, 30);
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        requestAnimationFrame(gameLoop);
      }
      
      // Mouse control for left paddle
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseY = e.clientY - rect.top;
        leftPaddle.y = mouseY - leftPaddle.height / 2;
      });
      
      gameLoop();
    }

    function initAsteroidsGame(ctx, canvas) {
      const player = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 20,
        angle: 0,
        velocity: { x: 0, y: 0 }
      };
      
      let asteroids = [];
      let bullets = [];
      let gameScore = 0;
      gameRunning = true;
      
      function createAsteroid() {
        const size = Math.random() * 30 + 20;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 1;
        
        return {
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: size,
          dx: Math.cos(angle) * speed,
          dy: Math.sin(angle) * speed
        };
      }
      
      function initAsteroids() {
        asteroids = [];
        for (let i = 0; i < 8; i++) {
          asteroids.push(createAsteroid());
        }
      }
      
      function drawPlayer() {
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.angle);
        
        ctx.fillStyle = '#4CAF50';
        ctx.beginPath();
        ctx.moveTo(0, -player.size);
        ctx.lineTo(-player.size / 2, player.size / 2);
        ctx.lineTo(player.size / 2, player.size / 2);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      
      function drawAsteroids() {
        ctx.fillStyle = '#FF9800';
        asteroids.forEach(asteroid => {
          ctx.beginPath();
          ctx.arc(asteroid.x, asteroid.y, asteroid.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      
      function drawBullets() {
        ctx.fillStyle = '#FF5722';
        bullets.forEach(bullet => {
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      
      function updatePlayer() {
        player.x += player.velocity.x;
        player.y += player.velocity.y;
        
        // Wrap around screen
        if (player.x < 0) player.x = canvas.width;
        if (player.x > canvas.width) player.x = 0;
        if (player.y < 0) player.y = canvas.height;
        if (player.y > canvas.height) player.y = 0;
      }
      
      function updateAsteroids() {
        asteroids.forEach(asteroid => {
          asteroid.x += asteroid.dx;
          asteroid.y += asteroid.dy;
          
          // Wrap around screen
          if (asteroid.x < 0) asteroid.x = canvas.width;
          if (asteroid.x > canvas.width) asteroid.x = 0;
          if (asteroid.y < 0) asteroid.y = canvas.height;
          if (asteroid.y > canvas.height) asteroid.y = 0;
        });
      }
      
      function updateBullets() {
        bullets.forEach((bullet, index) => {
          bullet.x += bullet.dx;
          bullet.y += bullet.dy;
          
          // Remove bullets that are off screen
          if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
            bullets.splice(index, 1);
          }
        });
      }
      
      function checkCollisions() {
        // Bullet-Asteroid collisions
        bullets.forEach((bullet, bulletIndex) => {
          asteroids.forEach((asteroid, asteroidIndex) => {
            const dx = bullet.x - asteroid.x;
            const dy = bullet.y - asteroid.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < asteroid.size) {
              bullets.splice(bulletIndex, 1);
              asteroids.splice(asteroidIndex, 1);
              gameScore += 50;
              
              // Create smaller asteroids
              if (asteroid.size > 15) {
                for (let i = 0; i < 2; i++) {
                  const newAsteroid = {
                    x: asteroid.x,
                    y: asteroid.y,
                    size: asteroid.size / 2,
                    dx: (Math.random() - 0.5) * 4,
                    dy: (Math.random() - 0.5) * 4
                  };
                  asteroids.push(newAsteroid);
                }
              }
            }
          });
        });
        
        // Player-Asteroid collisions
        asteroids.forEach(asteroid => {
          const dx = player.x - asteroid.x;
          const dy = player.y - asteroid.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < player.size + asteroid.size) {
            gameOver();
          }
        });
      }
      
      function shoot() {
        const bullet = {
          x: player.x + Math.cos(player.angle) * player.size,
          y: player.y + Math.sin(player.angle) * player.size,
          dx: Math.cos(player.angle) * 8,
          dy: Math.sin(player.angle) * 8
        };
        bullets.push(bullet);
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        updatePlayer();
        updateAsteroids();
        updateBullets();
        checkCollisions();
        
        drawPlayer();
        drawAsteroids();
        drawBullets();
        
        if (asteroids.length === 0) {
          initAsteroids();
        }
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        requestAnimationFrame(gameLoop);
      }
      
      // Controls
      document.addEventListener('keydown', (e) => {
        switch(e.key) {
          case 'ArrowLeft':
            player.angle -= 0.1;
            break;
          case 'ArrowRight':
            player.angle += 0.1;
            break;
          case 'ArrowUp':
            player.velocity.x += Math.cos(player.angle) * 0.5;
            player.velocity.y += Math.sin(player.angle) * 0.5;
            break;
          case ' ':
            shoot();
            break;
        }
      });
      
      initAsteroids();
      gameLoop();
    }

    function initPacmanGame(ctx, canvas) {
      const CELL_SIZE = 20;
      const PACMAN_SIZE = 18;
      
      const pacman = {
        x: 1,
        y: 1,
        direction: { x: 1, y: 0 },
        mouthOpen: true
      };
      
      let dots = [];
      let ghosts = [];
      let gameScore = 0;
      gameRunning = true;
      
      // Simple maze layout (1 = wall, 0 = path)
      const maze = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,1],
        [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
        [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,1],
        [1,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1],
        [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,1],
        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
      ];
      
      function initDots() {
        dots = [];
        for (let y = 0; y < maze.length; y++) {
          for (let x = 0; x < maze[y].length; x++) {
            if (maze[y][x] === 0) {
              dots.push({ x, y });
            }
          }
        }
      }
      
      function initGhosts() {
        ghosts = [
          { x: 18, y: 11, color: '#FF0000', direction: { x: -1, y: 0 } },
          { x: 18, y: 1, color: '#FF69B4', direction: { x: -1, y: 0 } }
        ];
      }
      
      function drawMaze() {
        ctx.fillStyle = '#0000FF';
        for (let y = 0; y < maze.length; y++) {
          for (let x = 0; x < maze[y].length; x++) {
            if (maze[y][x] === 1) {
              ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
          }
        }
      }
      
      function drawPacman() {
        ctx.save();
        ctx.translate(pacman.x * CELL_SIZE + CELL_SIZE / 2, pacman.y * CELL_SIZE + CELL_SIZE / 2);
        ctx.rotate(Math.atan2(pacman.direction.y, pacman.direction.x));
        
        ctx.fillStyle = '#FFFF00';
        ctx.beginPath();
        if (pacman.mouthOpen) {
          ctx.arc(0, 0, PACMAN_SIZE / 2, 0.2 * Math.PI, 1.8 * Math.PI);
        } else {
          ctx.arc(0, 0, PACMAN_SIZE / 2, 0, 2 * Math.PI);
        }
        ctx.lineTo(0, 0);
        ctx.fill();
        
        ctx.restore();
      }
      
      function drawDots() {
        ctx.fillStyle = '#FFFFFF';
        dots.forEach(dot => {
          ctx.beginPath();
          ctx.arc(dot.x * CELL_SIZE + CELL_SIZE / 2, dot.y * CELL_SIZE + CELL_SIZE / 2, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      
      function drawGhosts() {
        ghosts.forEach(ghost => {
          ctx.fillStyle = ghost.color;
          ctx.beginPath();
          ctx.arc(ghost.x * CELL_SIZE + CELL_SIZE / 2, ghost.y * CELL_SIZE + CELL_SIZE / 2, PACMAN_SIZE / 2, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      
      function updatePacman() {
        const newX = pacman.x + pacman.direction.x;
        const newY = pacman.y + pacman.direction.y;
        
        if (newX >= 0 && newX < maze[0].length && newY >= 0 && newY < maze.length && maze[newY][newX] === 0) {
          pacman.x = newX;
          pacman.y = newY;
        }
        
        // Animate mouth
        pacman.mouthOpen = !pacman.mouthOpen;
      }
      
      function updateGhosts() {
        ghosts.forEach(ghost => {
          const newX = ghost.x + ghost.direction.x;
          const newY = ghost.y + ghost.direction.y;
          
          if (newX >= 0 && newX < maze[0].length && newY >= 0 && newY < maze.length && maze[newY][newX] === 0) {
            ghost.x = newX;
            ghost.y = newY;
          } else {
            // Change direction randomly
            const directions = [{ x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }];
            ghost.direction = directions[Math.floor(Math.random() * directions.length)];
          }
        });
      }
      
      function checkCollisions() {
        // Pacman-Dot collisions
        dots.forEach((dot, index) => {
          if (pacman.x === dot.x && pacman.y === dot.y) {
            dots.splice(index, 1);
            gameScore += 10;
          }
        });
        
        // Pacman-Ghost collisions
        ghosts.forEach(ghost => {
          if (pacman.x === ghost.x && pacman.y === ghost.y) {
            gameOver();
          }
        });
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        updatePacman();
        updateGhosts();
        checkCollisions();
        
        drawMaze();
        drawDots();
        drawPacman();
        drawGhosts();
        
        if (dots.length === 0) {
          gameScore += 500; // Bonus for completing level
          setTimeout(() => {
            alert(`Level Complete! Score: ${gameScore}`);
            gameOver();
          }, 500);
          return;
        }
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        setTimeout(gameLoop, 200);
      }
      
      // Controls
      document.addEventListener('keydown', (e) => {
        switch(e.key) {
          case 'ArrowLeft':
            pacman.direction = { x: -1, y: 0 };
            break;
          case 'ArrowRight':
            pacman.direction = { x: 1, y: 0 };
            break;
          case 'ArrowUp':
            pacman.direction = { x: 0, y: -1 };
            break;
          case 'ArrowDown':
            pacman.direction = { x: 0, y: 1 };
            break;
        }
      });
      
      initDots();
      initGhosts();
      gameLoop();
    }

    function initTetrisGame(ctx, canvas) {
      // Clear any existing game loops
      if (window.tetrisGameLoopId) {
        cancelAnimationFrame(window.tetrisGameLoopId);
        window.tetrisGameLoopId = null;
      }
      
      const BLOCK_SIZE = 20;
      const COLS = canvas.width / BLOCK_SIZE;
      const ROWS = canvas.height / BLOCK_SIZE;
      
      let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
      let currentPiece = null;
      let gameScore = 0;
      gameRunning = true;
      
      // Tetris pieces
      const PIECES = [
        [[1,1,1,1]], // I
        [[1,1],[1,1]], // O
        [[1,1,1],[0,1,0]], // T
        [[1,1,1],[1,0,0]], // L
        [[1,1,1],[0,0,1]], // J
        [[1,1,0],[0,1,1]], // S
        [[0,1,1],[1,1,0]]  // Z
      ];
      
      function createPiece() {
        const piece = PIECES[Math.floor(Math.random() * PIECES.length)];
        return {
          shape: piece,
          x: Math.floor(COLS / 2) - Math.floor(piece[0].length / 2),
          y: 0
        };
      }
      
      function drawBoard() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            if (board[y][x]) {
              ctx.fillStyle = '#2196F3';
              ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            }
          }
        }
      }
      
      function drawPiece(piece) {
        ctx.fillStyle = '#FF5722';
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              ctx.fillRect((piece.x + x) * BLOCK_SIZE, (piece.y + y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            }
          }
        }
      }
      
      function isValid(piece, dx = 0, dy = 0) {
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              const newX = piece.x + x + dx;
              const newY = piece.y + y + dy;
              if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX])) {
                return false;
              }
            }
          }
        }
        return true;
      }
      
      function placePiece(piece) {
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              board[piece.y + y][piece.x + x] = 1;
            }
          }
        }
      }
      
      function clearLines() {
        let linesCleared = 0;
        for (let y = ROWS - 1; y >= 0; y--) {
          if (board[y].every(cell => cell)) {
            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            linesCleared++;
            y++;
          }
        }
        if (linesCleared > 0) {
          gameScore += linesCleared * 100;
        }
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        if (!currentPiece) {
          currentPiece = createPiece();
          // Check if the new piece can be placed
          if (!isValid(currentPiece)) {
            // Try to move the piece down if it's stuck at the top
            currentPiece.y += 1;
            if (!isValid(currentPiece)) {
              gameOver();
              return;
            }
          }
        }
        
        if (isValid(currentPiece, 0, 1)) {
          currentPiece.y++;
        } else {
          placePiece(currentPiece);
          clearLines();
          currentPiece = null;
        }
        
        drawBoard();
        if (currentPiece) {
          drawPiece(currentPiece);
        }
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        // Use requestAnimationFrame for smoother game loop
        window.tetrisGameLoopId = requestAnimationFrame(gameLoop);
      }
      
      document.addEventListener('keydown', (e) => {
        if (!currentPiece || !gameRunning) return;
        
        if (e.key === 'ArrowLeft' && isValid(currentPiece, -1, 0)) {
          currentPiece.x--;
        } else if (e.key === 'ArrowRight' && isValid(currentPiece, 1, 0)) {
          currentPiece.x++;
        } else if (e.key === 'ArrowDown' && isValid(currentPiece, 0, 1)) {
          currentPiece.y++;
        } else if (e.key === 'ArrowUp') {
          // Rotate piece
          const rotated = [];
          for (let x = 0; x < currentPiece.shape[0].length; x++) {
            rotated[x] = [];
            for (let y = currentPiece.shape.length - 1; y >= 0; y--) {
              rotated[x][currentPiece.shape.length - 1 - y] = currentPiece.shape[y][x];
            }
          }
          const originalShape = currentPiece.shape;
          currentPiece.shape = rotated;
          if (!isValid(currentPiece)) {
            currentPiece.shape = originalShape;
          }
        }
      });
      
      gameLoop();
    }

    // Hair Styling Game
    function initHairGame(ctx, canvas) {
      // Clear any existing game loops
      if (window.hairGameLoopId) {
        clearTimeout(window.hairGameLoopId);
        window.hairGameLoopId = null;
      }
      
      let hair = [];
      let tools = ['scissors', 'comb', 'spray'];
      let currentTool = 'scissors';
      let score = 0;
      let timeLeft = 60;
      gameRunning = true;
      
      // Initialize hair strands
      function initHair() {
        hair = [];
        for (let i = 0; i < 20; i++) {
          hair.push({
            x: Math.random() * (canvas.width - 100) + 50,
            y: Math.random() * (canvas.height - 200) + 100,
            length: 30 + Math.random() * 40,
            styled: false,
            color: `hsl(${Math.random() * 60 + 20}, 70%, 50%)`
          });
        }
      }
      
      function drawHair() {
        hair.forEach(strand => {
          ctx.strokeStyle = strand.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(strand.x, strand.y);
          ctx.lineTo(strand.x, strand.y - strand.length);
          ctx.stroke();
          
          if (strand.styled) {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(strand.x, strand.y - strand.length, 5, 0, Math.PI * 2);
            ctx.fill();
          }
        });
      }
      
      function drawTools() {
        ctx.fillStyle = '#333';
        ctx.fillRect(10, canvas.height - 60, 200, 50);
        
        tools.forEach((tool, index) => {
          const x = 20 + index * 60;
          const y = canvas.height - 50;
          
          ctx.fillStyle = currentTool === tool ? '#FFD700' : '#FFF';
          ctx.fillRect(x, y, 50, 30);
          
          ctx.fillStyle = '#333';
          ctx.font = '12px Arial';
          ctx.fillText(tool, x + 5, y + 20);
        });
      }
      
      function checkClick(x, y) {
        hair.forEach(strand => {
          const distance = Math.sqrt((x - strand.x) ** 2 + (y - strand.y) ** 2);
          if (distance < 20 && !strand.styled) {
            strand.styled = true;
            score += 10;
            gameScore = score;
            if (currentTool === 'scissors') {
              strand.length *= 0.8;
            }
          }
        });
      }
      
      function gameLoop() {
        if (!gameRunning) {
          if (window.hairGameLoopId) {
            cancelAnimationFrame(window.hairGameLoopId);
            window.hairGameLoopId = null;
          }
          return;
        }
        
        ctx.fillStyle = '#F0F8FF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        drawHair();
        drawTools();
        
        // Draw UI
        ctx.fillStyle = '#333';
        ctx.font = '20px Arial';
        ctx.fillText(`Score: ${score}`, 10, 30);
        ctx.fillText(`Time: ${timeLeft}`, 10, 60);
        
        timeLeft--;
        if (timeLeft <= 0) {
          gameOver();
          return;
        }
        
        window.hairGameLoopId = requestAnimationFrame(gameLoop);
      }
      
      // Remove existing event listeners
      canvas.removeEventListener('click', checkClick);
      canvas.removeEventListener('keydown', handleKeydown);
      
      function handleClick(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        checkClick(x, y);
      }
      
      function handleKeydown(e) {
        if (e.key >= '1' && e.key <= '3') {
          currentTool = tools[parseInt(e.key) - 1];
        }
      }
      
      canvas.addEventListener('click', handleClick);
      canvas.addEventListener('keydown', handleKeydown);
      
      initHair();
      gameLoop();
    }

    // Zombie Slasher Game
    function initZombieGame(ctx, canvas) {
      // Clear any existing game loops
      if (window.zombieGameLoopId) {
        cancelAnimationFrame(window.zombieGameLoopId);
        window.zombieGameLoopId = null;
      }
      
      let player = { x: canvas.width / 2, y: canvas.height - 50, sword: 0 };
      let zombies = [];
      let score = 0;
      let timeLeft = 60;
      gameRunning = true;
      
      function spawnZombie() {
        zombies.push({
          x: Math.random() * canvas.width,
          y: -30,
          speed: 1 + Math.random() * 2,
          health: 3
        });
      }
      
      function drawPlayer() {
        // Player body
        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(player.x - 15, player.y - 30, 30, 30);
        
        // Sword
        if (player.sword > 0) {
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(player.x, player.y - 15);
          ctx.lineTo(player.x + 40, player.y - 15);
          ctx.stroke();
          player.sword--;
        }
      }
      
      function drawZombies() {
        zombies.forEach(zombie => {
          ctx.fillStyle = '#8BC34A';
          ctx.fillRect(zombie.x - 15, zombie.y - 30, 30, 30);
          
          // Health bar
          ctx.fillStyle = '#FF5722';
          ctx.fillRect(zombie.x - 15, zombie.y - 35, 30 * (zombie.health / 3), 5);
        });
      }
      
      function updateZombies() {
        zombies.forEach((zombie, index) => {
          zombie.y += zombie.speed;
          
          // Check collision with sword
          if (player.sword > 0 && 
              Math.abs(zombie.x - player.x) < 40 && 
              Math.abs(zombie.y - player.y) < 30) {
            zombie.health--;
            if (zombie.health <= 0) {
                           zombies.splice(index, 1);
             score += 20;
             gameScore = score;
            }
          }
          
          // Remove zombies that pass the player
          if (zombie.y > canvas.height) {
            zombies.splice(index, 1);
          }
        });
      }
      
      function gameLoop() {
        if (!gameRunning) {
          if (window.zombieGameLoopId) {
            cancelAnimationFrame(window.zombieGameLoopId);
            window.zombieGameLoopId = null;
          }
          return;
        }
        
        ctx.fillStyle = '#2C3E50';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Spawn zombies
        if (Math.random() < 0.02) {
          spawnZombie();
        }
        
        updateZombies();
        drawZombies();
        drawPlayer();
        
        // Draw UI
        ctx.fillStyle = '#FFF';
        ctx.font = '20px Arial';
        ctx.fillText(`Score: ${score}`, 10, 30);
        ctx.fillText(`Time: ${timeLeft}`, 10, 60);
        
        timeLeft--;
        if (timeLeft <= 0) {
          gameOver();
          return;
        }
        
        window.zombieGameLoopId = requestAnimationFrame(gameLoop);
      }
      
      // Remove existing event listeners
      canvas.removeEventListener('mousemove', handleMouseMove);
      canvas.removeEventListener('click', handleClick);
      
      function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        player.x = e.clientX - rect.left;
      }
      
      function handleClick() {
        player.sword = 10;
      }
      
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('click', handleClick);
      
      gameLoop();
    }

    // Cooking Master Game
    function initCookingGame(ctx, canvas) {
      // Clear any existing game loops
      if (window.cookingGameLoopId) {
        cancelAnimationFrame(window.cookingGameLoopId);
        window.cookingGameLoopId = null;
      }
      
      let ingredients = [];
      let pot = { x: canvas.width / 2, y: canvas.height - 100, cooking: false };
      let score = 0;
      let timeLeft = 60;
      gameRunning = true;
      
      const ingredientTypes = ['tomato', 'onion', 'carrot', 'meat'];
      
      function spawnIngredient() {
        ingredients.push({
          x: Math.random() * canvas.width,
          y: -30,
          type: ingredientTypes[Math.floor(Math.random() * ingredientTypes.length)],
          collected: false
        });
      }
      
      function drawPot() {
        ctx.fillStyle = '#8D6E63';
        ctx.fillRect(pot.x - 30, pot.y - 20, 60, 40);
        
        if (pot.cooking) {
          ctx.fillStyle = '#FF5722';
          ctx.fillRect(pot.x - 25, pot.y - 15, 50, 30);
        }
      }
      
      function drawIngredients() {
        ingredients.forEach(ingredient => {
          if (!ingredient.collected) {
            ctx.fillStyle = ingredient.type === 'tomato' ? '#F44336' :
                           ingredient.type === 'onion' ? '#FFF' :
                           ingredient.type === 'carrot' ? '#FF9800' : '#8D6E63';
            
            ctx.fillRect(ingredient.x - 10, ingredient.y - 10, 20, 20);
          }
        });
      }
      
      function updateIngredients() {
        ingredients.forEach((ingredient, index) => {
          ingredient.y += 2;
          
          // Check collision with pot
          if (!ingredient.collected && 
              Math.abs(ingredient.x - pot.x) < 30 && 
              Math.abs(ingredient.y - pot.y) < 30) {
                         ingredient.collected = true;
             score += 10;
             gameScore = score;
            pot.cooking = true;
            setTimeout(() => { pot.cooking = false; }, 1000);
          }
          
          // Remove ingredients that fall off screen
          if (ingredient.y > canvas.height) {
            ingredients.splice(index, 1);
          }
        });
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        ctx.fillStyle = '#E8F5E8';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Spawn ingredients
        if (Math.random() < 0.03) {
          spawnIngredient();
        }
        
        updateIngredients();
        drawIngredients();
        drawPot();
        
        // Draw UI
        ctx.fillStyle = '#333';
        ctx.font = '20px Arial';
        ctx.fillText(`Score: ${score}`, 10, 30);
        ctx.fillText(`Time: ${timeLeft}`, 10, 60);
        
        timeLeft--;
        if (timeLeft <= 0) {
          gameOver();
          return;
        }
        
        window.cookingGameLoopId = requestAnimationFrame(gameLoop);
      }
      
      // Remove existing event listeners
      canvas.removeEventListener('mousemove', handleMouseMove);
      
      function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        pot.x = e.clientX - rect.left;
      }
      
      canvas.addEventListener('mousemove', handleMouseMove);
      
      gameLoop();
    }

    // Speed Racing Game
    function initRacingGame(ctx, canvas) {
      // Clear any existing game loops
      if (window.racingGameLoopId) {
        cancelAnimationFrame(window.racingGameLoopId);
        window.racingGameLoopId = null;
      }
      
      let car = { x: canvas.width / 2, y: canvas.height - 100, speed: 0 };
      let obstacles = [];
      let score = 0;
      let timeLeft = 60;
      gameRunning = true;
      
      function spawnObstacle() {
        obstacles.push({
          x: Math.random() * canvas.width,
          y: -50,
          width: 60,
          height: 30
        });
      }
      
      function drawCar() {
        ctx.fillStyle = '#2196F3';
        ctx.fillRect(car.x - 20, car.y - 30, 40, 60);
        
        // Car details
        ctx.fillStyle = '#1976D2';
        ctx.fillRect(car.x - 15, car.y - 25, 30, 50);
      }
      
      function drawObstacles() {
        ctx.fillStyle = '#F44336';
        obstacles.forEach(obstacle => {
          ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
        });
      }
      
      function updateObstacles() {
        obstacles.forEach((obstacle, index) => {
          obstacle.y += 5;
          
          // Check collision
          if (car.x < obstacle.x + obstacle.width &&
              car.x + 40 > obstacle.x &&
              car.y < obstacle.y + obstacle.height &&
              car.y + 60 > obstacle.y) {
            gameOver();
            return;
          }
          
          // Remove obstacles that pass the car
          if (obstacle.y > canvas.height) {
                       obstacles.splice(index, 1);
           score += 10;
           gameScore = score;
          }
        });
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        ctx.fillStyle = '#2E7D32';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Road lines
        ctx.strokeStyle = '#FFF';
        ctx.lineWidth = 5;
        for (let i = 0; i < canvas.width; i += 100) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, canvas.height);
          ctx.stroke();
        }
        
        // Spawn obstacles
        if (Math.random() < 0.02) {
          spawnObstacle();
        }
        
        updateObstacles();
        drawObstacles();
        drawCar();
        
        // Draw UI
        ctx.fillStyle = '#FFF';
        ctx.font = '20px Arial';
        ctx.fillText(`Score: ${score}`, 10, 30);
        ctx.fillText(`Time: ${timeLeft}`, 10, 60);
        
        timeLeft--;
        if (timeLeft <= 0) {
          gameOver();
          return;
        }
        
        window.racingGameLoopId = requestAnimationFrame(gameLoop);
      }
      
      // Remove existing event listeners
      canvas.removeEventListener('mousemove', handleMouseMove);
      
      function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        car.x = e.clientX - rect.left;
      }
      
      canvas.addEventListener('mousemove', handleMouseMove);
      
      gameLoop();
    }

    function initPuzzleGame(ctx, canvas) {
      const TILE_SIZE = 80;
      const GRID_SIZE = 3;
      const BOARD_SIZE = TILE_SIZE * GRID_SIZE;
      
      let tiles = [];
      let emptyPos = { x: GRID_SIZE - 1, y: GRID_SIZE - 1 };
      let gameScore = 0;
      let moves = 0;
      gameRunning = true;
      
      // Initialize tiles
      function initTiles() {
        tiles = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE - 1; i++) {
          tiles.push(i + 1);
        }
        tiles.push(0); // Empty tile
        shuffleTiles();
      }
      
      function shuffleTiles() {
        for (let i = tiles.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
        }
        // Find empty position
        const emptyIndex = tiles.indexOf(0);
        emptyPos.x = emptyIndex % GRID_SIZE;
        emptyPos.y = Math.floor(emptyIndex / GRID_SIZE);
      }
      
      function drawTiles() {
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            const index = y * GRID_SIZE + x;
            const value = tiles[index];
            
            if (value !== 0) {
              const tileX = x * TILE_SIZE + 10;
              const tileY = y * TILE_SIZE + 10;
              
              // Draw tile background
              ctx.fillStyle = '#9C27B0';
              ctx.fillRect(tileX, tileY, TILE_SIZE - 20, TILE_SIZE - 20);
              
              // Draw number
              ctx.fillStyle = '#fff';
              ctx.font = 'bold 24px Arial';
              ctx.textAlign = 'center';
              ctx.fillText(value.toString(), tileX + (TILE_SIZE - 20) / 2, tileY + (TILE_SIZE - 20) / 2 + 8);
            }
          }
        }
      }
      
      function canMove(x, y) {
        return (Math.abs(x - emptyPos.x) === 1 && y === emptyPos.y) ||
               (Math.abs(y - emptyPos.y) === 1 && x === emptyPos.x);
      }
      
      function moveTile(x, y) {
        if (!canMove(x, y)) return false;
        
        const fromIndex = y * GRID_SIZE + x;
        const toIndex = emptyPos.y * GRID_SIZE + emptyPos.x;
        
        // Swap tiles
        [tiles[fromIndex], tiles[toIndex]] = [tiles[toIndex], tiles[fromIndex]];
        
        // Update empty position
        emptyPos.x = x;
        emptyPos.y = y;
        
        moves++;
        return true;
      }
      
      function isSolved() {
        for (let i = 0; i < tiles.length - 1; i++) {
          if (tiles[i] !== i + 1) return false;
        }
        return tiles[tiles.length - 1] === 0;
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        drawTiles();
        
        if (isSolved()) {
          gameScore = Math.max(1000 - moves * 10, 100);
          setTimeout(() => {
            alert(`Puzzle Solved! Score: ${gameScore}`);
            gameOver();
          }, 500);
        }
        
        document.getElementById('game-score').textContent = `Moves: ${moves}`;
      }
      
      // Mouse/touch controls
      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
        const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);
        
        if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
          if (moveTile(x, y)) {
            gameLoop();
          }
        }
      });
      
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        let moved = false;
        
        switch(e.key) {
          case 'ArrowUp':
            moved = moveTile(emptyPos.x, emptyPos.y + 1);
            break;
          case 'ArrowDown':
            moved = moveTile(emptyPos.x, emptyPos.y - 1);
            break;
          case 'ArrowLeft':
            moved = moveTile(emptyPos.x + 1, emptyPos.y);
            break;
          case 'ArrowRight':
            moved = moveTile(emptyPos.x - 1, emptyPos.y);
            break;
        }
        
        if (moved) {
          gameLoop();
        }
      });
      
      initTiles();
      gameLoop();
    }

    function initFlappyGame(ctx, canvas) {
      const bird = {
        x: 50,
        y: canvas.height / 2,
        velocity: 0,
        size: 20
      };
      
      let pipes = [];
      let gameScore = 0;
      gameRunning = true;
      
      function createPipe() {
        const gap = 150;
        const gapY = Math.random() * (canvas.height - gap - 100) + 50;
        return {
          x: canvas.width,
          gapY: gapY,
          gapHeight: gap,
          width: 50
        };
      }
      
      function drawBird() {
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.arc(bird.x, bird.y, bird.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw eye
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(bird.x + 8, bird.y - 5, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      function drawPipes() {
        ctx.fillStyle = '#4CAF50';
        pipes.forEach(pipe => {
          // Top pipe
          ctx.fillRect(pipe.x, 0, pipe.width, pipe.gapY);
          // Bottom pipe
          ctx.fillRect(pipe.x, pipe.gapY + pipe.gapHeight, pipe.width, canvas.height - pipe.gapY - pipe.gapHeight);
        });
      }
      
      function updateBird() {
        bird.velocity += 0.8; // Gravity
        bird.y += bird.velocity;
      }
      
      function updatePipes() {
        pipes.forEach(pipe => {
          pipe.x -= 3;
        });
        
        // Remove pipes that are off screen
        pipes = pipes.filter(pipe => pipe.x + pipe.width > 0);
        
        // Add new pipes
        if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 300) {
          pipes.push(createPipe());
        }
      }
      
      function checkCollision() {
        // Check wall collision
        if (bird.y - bird.size < 0 || bird.y + bird.size > canvas.height) {
          return true;
        }
        
        // Check pipe collision
        return pipes.some(pipe => {
          return bird.x + bird.size > pipe.x && 
                 bird.x - bird.size < pipe.x + pipe.width &&
                 (bird.y - bird.size < pipe.gapY || bird.y + bird.size > pipe.gapY + pipe.gapHeight);
        });
      }
      
      function checkScore() {
        pipes.forEach(pipe => {
          if (pipe.x + pipe.width < bird.x && !pipe.passed) {
            gameScore++;
            pipe.passed = true;
          }
        });
      }
      
      function gameLoop() {
        if (!gameRunning) return;
        
        // Clear canvas
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        updateBird();
        updatePipes();
        checkScore();
        
        drawPipes();
        drawBird();
        
        if (checkCollision()) {
          gameOver();
          return;
        }
        
        document.getElementById('game-score').textContent = `Score: ${gameScore}`;
        
        requestAnimationFrame(gameLoop);
      }
      
      // Controls
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          bird.velocity = -12;
        }
      });
      
      canvas.addEventListener('click', () => {
        bird.velocity = -12;
      });
      
      // Touch controls for mobile
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        bird.velocity = -12;
      });
      
      gameLoop();
    }

    function pauseGame() {
      gameRunning = !gameRunning;
      document.getElementById('pause-btn').textContent = gameRunning ? 'Pause' : 'Resume';
      console.log('üéÆ Game paused/resumed:', !gameRunning);
    }

    function restartGame() {
      gameRunning = false;
      gameScore = 0;
      console.log('üéÆ Restarting game:', currentGame);
      
      // Start countdown again
      startCountdown(() => {
        initGame(currentGame);
      });
    }

    function exitGame() {
      gameRunning = false;
      console.log('üéÆ Exiting game:', currentGame);
      
      // Clear any game loops
      if (window.gameLoopId) {
        cancelAnimationFrame(window.gameLoopId);
        window.gameLoopId = null;
      }
      if (window.snakeGameLoopId) {
        cancelAnimationFrame(window.snakeGameLoopId);
        window.snakeGameLoopId = null;
      }
      if (window.tetrisGameLoopId) {
        cancelAnimationFrame(window.tetrisGameLoopId);
        window.tetrisGameLoopId = null;
      }
      if (window.hairGameLoopId) {
        cancelAnimationFrame(window.hairGameLoopId);
        window.hairGameLoopId = null;
      }
      if (window.zombieGameLoopId) {
        cancelAnimationFrame(window.zombieGameLoopId);
        window.zombieGameLoopId = null;
      }
      if (window.cookingGameLoopId) {
        cancelAnimationFrame(window.cookingGameLoopId);
        window.cookingGameLoopId = null;
      }
      if (window.racingGameLoopId) {
        cancelAnimationFrame(window.racingGameLoopId);
        window.racingGameLoopId = null;
      }
      
      document.getElementById('game-area').classList.remove('active');
      document.getElementById('main-container').style.display = 'block';
      currentGame = null;
      
      // Update token display without resetting
      if (currentEmail) {
        getTokenCount(currentEmail).then(tokens => {
          console.log('üîÑ Current tokens after game exit:', tokens);
          updateTokenDisplay(currentEmail);
        });
      }
    }

    function gameOver() {
      gameRunning = false;
      console.log('üéÆ Game Over! Final Score:', gameScore);
      
      // Calculate tokens earned based on score
      let tokensEarned = 0;
      if (gameScore > 0) {
        tokensEarned = Math.max(1, Math.floor(gameScore / 100));
      }
      
      if (tokensEarned > 0 && currentEmail) {
        // Award tokens for good performance
        getTokenCount(currentEmail).then(currentTokens => {
          const newTokens = currentTokens + tokensEarned;
          setTokenCount(currentEmail, newTokens).then(() => {
            updateTokenDisplay(currentEmail);
            alert(`Game Over! Final Score: ${gameScore}\nYou earned ${tokensEarned} bonus tokens!`);
            // Don't call exitGame() here - just clean up and return to main menu
            cleanupGame();
          });
        });
      } else {
        alert(`Game Over! Final Score: ${gameScore}`);
        // Don't call exitGame() here - just clean up and return to main menu
        cleanupGame();
      }
    }
    
    function cleanupGame() {
      // Clear any game loops
      if (window.gameLoopId) {
        cancelAnimationFrame(window.gameLoopId);
        window.gameLoopId = null;
      }
      if (window.snakeGameLoopId) {
        cancelAnimationFrame(window.snakeGameLoopId);
        window.snakeGameLoopId = null;
      }
      if (window.tetrisGameLoopId) {
        cancelAnimationFrame(window.tetrisGameLoopId);
        window.tetrisGameLoopId = null;
      }
      if (window.hairGameLoopId) {
        cancelAnimationFrame(window.hairGameLoopId);
        window.hairGameLoopId = null;
      }
      if (window.zombieGameLoopId) {
        cancelAnimationFrame(window.zombieGameLoopId);
        window.zombieGameLoopId = null;
      }
      if (window.cookingGameLoopId) {
        cancelAnimationFrame(window.cookingGameLoopId);
        window.cookingGameLoopId = null;
      }
      if (window.racingGameLoopId) {
        cancelAnimationFrame(window.racingGameLoopId);
        window.racingGameLoopId = null;
      }
      
      document.getElementById('game-area').classList.remove('active');
      document.getElementById('main-container').style.display = 'block';
      currentGame = null;
      
      // Update token display without resetting
      if (currentEmail) {
        getTokenCount(currentEmail).then(tokens => {
          console.log('üîÑ Current tokens after game cleanup:', tokens);
          updateTokenDisplay(currentEmail);
        });
      }
    }

    // Netlify Identity integration
    function checkAuth() {
      const user = netlifyIdentity.currentUser();
      if (user) {
        currentUser = user;
        currentEmail = user.email;
        document.getElementById('user-email').textContent = 'Logged in as: ' + user.email;
        updateTokenDisplay(user.email);
      } else {
        currentUser = null;
        currentEmail = null;
        document.getElementById('user-email').textContent = 'Not signed in.';
      }
    }

    document.addEventListener("DOMContentLoaded", function() {
      if (window.netlifyIdentity) {
        netlifyIdentity.on("login", user => {
          currentUser = user;
          currentEmail = user.email;
          checkAuth();
        });
        netlifyIdentity.on("logout", () => {
          currentUser = null;
          currentEmail = null;
          checkAuth();
        });
        netlifyIdentity.on("init", () => {
          checkAuth();
        });
        netlifyIdentity.init();
      }
      checkAuth();
    });
  </script>
</body>
</html> 